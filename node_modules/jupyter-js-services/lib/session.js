// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
'use strict';
var utils = require('jupyter-js-utils');
var phosphor_signaling_1 = require('phosphor-signaling');
var ikernel_1 = require('./ikernel');
var kernel_1 = require('./kernel');
var validate = require('./validate');
/**
 * The url for the session service.
 */
var SESSION_SERVICE_URL = 'api/sessions';
/**
 * An implementation of a notebook session manager.
 */
var NotebookSessionManager = (function () {
    /**
     * Construct a new notebook session manager.
     *
     * @param options - The default options for each session.
     */
    function NotebookSessionManager(options) {
        this._options = null;
        this._options = utils.copy(options);
    }
    /**
     * Get the available kernel specs. See also [[getKernelSpecs]].
     *
     * @param options - Overrides for the default options.
     */
    NotebookSessionManager.prototype.getSpecs = function (options) {
        return kernel_1.getKernelSpecs(this._getOptions(options));
    };
    /**
     * List the running sessions.  See also [[listRunningSessions]].
     *
     * @param options - Overrides for the default options.
     */
    NotebookSessionManager.prototype.listRunning = function (options) {
        return listRunningSessions(this._getOptions(options));
    };
    /**
     * Start a new session.  See also [[startNewSession]].
     *
     * @param options - Overrides for the default options, must include a
     *   `'notebookPath'`.
     */
    NotebookSessionManager.prototype.startNew = function (options) {
        return startNewSession(this._getOptions(options));
    };
    /**
     * Connect to a running session.  See also [[connectToSession]].
     *
     * @param options - Overrides for the default options.
     */
    NotebookSessionManager.prototype.connectTo = function (id, options) {
        if (options) {
            options = this._getOptions(options);
        }
        else {
            options = utils.copy(this._options);
        }
        return connectToSession(id, options);
    };
    /**
     * Get optionally overidden options.
     */
    NotebookSessionManager.prototype._getOptions = function (options) {
        if (options) {
            options = utils.extend(utils.copy(this._options), options);
        }
        else {
            options = this._options;
        }
        return options;
    };
    return NotebookSessionManager;
})();
exports.NotebookSessionManager = NotebookSessionManager;
/**
 * List the running sessions.
 *
 * #### Notes
 * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/jupyter-js-services/master/rest_api.yaml#!/sessions), and validates the response.
 *
 * The promise is fulfilled on a valid response and rejected otherwise.
 */
function listRunningSessions(options) {
    var baseUrl = options.baseUrl || utils.getBaseUrl();
    var url = utils.urlPathJoin(options.baseUrl, SESSION_SERVICE_URL);
    var ajaxSettings = utils.copy(options.ajaxSettings) || {};
    ajaxSettings.method = 'GET';
    ajaxSettings.dataType = 'json';
    ajaxSettings.cache = false;
    return utils.ajaxRequest(url, ajaxSettings).then(function (success) {
        if (success.xhr.status !== 200) {
            throw Error('Invalid Status: ' + success.xhr.status);
        }
        if (!Array.isArray(success.data)) {
            throw Error('Invalid Session list');
        }
        for (var i = 0; i < success.data.length; i++) {
            validate.validateSessionId(success.data[i]);
        }
        return success.data;
    }, onSessionError);
}
exports.listRunningSessions = listRunningSessions;
/**
 * Start a new session.
 *
 * #### Notes
 * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/jupyter-js-services/master/rest_api.yaml#!/sessions), and validates the response.
 *
 * The promise is fulfilled on a valid response and rejected otherwise.

 * Wrap the result in an NotebookSession object. The promise is fulfilled
 * when the session is fully ready to send the first message. If
 * the session fails to become ready, the promise is rejected.
 */
function startNewSession(options) {
    var baseUrl = options.baseUrl || utils.getBaseUrl();
    var url = utils.urlPathJoin(baseUrl, SESSION_SERVICE_URL);
    var model = {
        kernel: { name: options.kernelName },
        notebook: { path: options.notebookPath }
    };
    var ajaxSettings = utils.copy(options.ajaxSettings) || {};
    ajaxSettings.method = 'POST';
    ajaxSettings.dataType = 'json';
    ajaxSettings.data = JSON.stringify(model);
    ajaxSettings.contentType = 'application/json';
    ajaxSettings.cache = false;
    return utils.ajaxRequest(url, ajaxSettings).then(function (success) {
        if (success.xhr.status !== 201) {
            throw Error('Invalid Status: ' + success.xhr.status);
        }
        var sessionId = success.data;
        validate.validateSessionId(success.data);
        return createSession(sessionId, options);
    }, onSessionError);
}
exports.startNewSession = startNewSession;
/**
 * Connect to a running notebook session.
 *
 * #### Notes
 * If the session was already started via `startNewSession`, the existing
 * NotebookSession object is used as the fulfillment value.
 *
 * Otherwise, if `options` are given, we attempt to connect to the existing
 * session found by calling `listRunningSessions`.
 * The promise is fulfilled when the session is fully ready to send
 * the first message. If the session fails to become ready, the promise is
 * rejected.
 *
 * If the session was not already started and no `options` are given,
 * the promise is rejected.
 */
function connectToSession(id, options) {
    var session = runningSessions.get(id);
    if (session) {
        return Promise.resolve(session);
    }
    if (options === void 0) {
        return Promise.reject(new Error('Please specify session options'));
    }
    return listRunningSessions(options).then(function (sessionIds) {
        sessionIds = sessionIds.filter(function (k) { return k.id === id; });
        if (!sessionIds.length) {
            return typedThrow('No running session with id: ' + id);
        }
        return createSession(sessionIds[0], options);
    });
}
exports.connectToSession = connectToSession;
/**
 * Create a Promise for a NotebookSession object.
 *
 * Fulfilled when the NotebookSession is Starting, or rejected if Dead.
 */
function createSession(sessionId, options) {
    var baseUrl = options.baseUrl || utils.getBaseUrl();
    options.notebookPath = sessionId.notebook.path;
    var kernelOptions = {
        name: sessionId.kernel.name,
        baseUrl: options.baseUrl,
        wsUrl: options.wsUrl,
        username: options.username,
        clientId: options.clientId,
        ajaxSettings: options.ajaxSettings
    };
    return kernel_1.connectToKernel(sessionId.kernel.id, kernelOptions).then(function (kernel) {
        var session = new NotebookSession(options, sessionId.id, kernel);
        runningSessions.set(session.id, session);
        return session;
    }).catch(function (error) {
        return typedThrow('Session failed to start: ' + error.message);
    });
}
/**
 * A module private store for running sessions.
 */
var runningSessions = new Map();
/**
 * Session object for accessing the session REST api. The session
 * should be used to start kernels and then shut them down -- for
 * all other operations, the kernel object should be used.
 **/
var NotebookSession = (function () {
    /**
     * Construct a new session.
     */
    function NotebookSession(options, id, kernel) {
        this._id = '';
        this._notebookPath = '';
        this._ajaxSettings = '';
        this._kernel = null;
        this._url = '';
        this._isDead = false;
        this.ajaxSettings = options.ajaxSettings || {};
        this._id = id;
        this._notebookPath = options.notebookPath;
        this._kernel = kernel;
        this._url = utils.urlPathJoin(options.baseUrl, SESSION_SERVICE_URL, this._id);
        this._kernel.statusChanged.connect(this._kernelStatusChanged, this);
    }
    Object.defineProperty(NotebookSession.prototype, "sessionDied", {
        /**
         * A signal emitted when the session dies.
         */
        get: function () {
            return NotebookSession.sessionDiedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotebookSession.prototype, "id", {
        /**
         * Get the session id.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotebookSession.prototype, "kernel", {
        /**
         * Get the session kernel object.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._kernel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotebookSession.prototype, "status", {
        /**
         * The current status of the session, and is a delegate to the kernel status.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._kernel.status;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotebookSession.prototype, "notebookPath", {
        /**
         * Get the notebook path.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._notebookPath;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotebookSession.prototype, "ajaxSettings", {
        /**
         * Get a copy of the default ajax settings for the session.
         */
        get: function () {
            return JSON.parse(this._ajaxSettings);
        },
        /**
         * Set the default ajax settings for the session.
         */
        set: function (value) {
            this._ajaxSettings = JSON.stringify(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotebookSession.prototype, "isDisposed", {
        /**
         * Test whether the session has been disposed.
         *
         * #### Notes
         * This is a read-only property which is always safe to access.
         */
        get: function () {
            return (this._kernel === null);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the session.
     */
    NotebookSession.prototype.dispose = function () {
        this._kernel = null;
        this._isDead = true;
        phosphor_signaling_1.clearSignalData(this);
        runningSessions.delete(this._id);
    };
    /**
     * Rename or move a notebook.
     *
     * @param path - The new notebook path.
     *
     * #### Notes
     * This uses the Notebook REST API, and the response is validated.
     * The promise is fulfilled on a valid response and rejected otherwise.
     */
    NotebookSession.prototype.renameNotebook = function (path) {
        var _this = this;
        if (this._isDead) {
            return Promise.reject(new Error('Session is dead'));
        }
        var model = {
            kernel: { name: this._kernel.name, id: this._kernel.id },
            notebook: { path: path }
        };
        var ajaxSettings = this.ajaxSettings;
        ajaxSettings.method = 'PATCH';
        ajaxSettings.dataType = 'json';
        ajaxSettings.data = JSON.stringify(model);
        ajaxSettings.contentType = 'application/json';
        ajaxSettings.cache = false;
        return utils.ajaxRequest(this._url, ajaxSettings).then(function (success) {
            if (success.xhr.status !== 200) {
                throw Error('Invalid Status: ' + success.xhr.status);
            }
            var data = success.data;
            validate.validateSessionId(data);
            _this._notebookPath = data.notebook.path;
        }, onSessionError);
    };
    /**
     * Kill the kernel and shutdown the session.
     *
     * #### Notes
     * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/jupyter-js-services/master/rest_api.yaml#!/sessions), and validates the response.
     *
     * The promise is fulfilled on a valid response and rejected otherwise.
     */
    NotebookSession.prototype.shutdown = function () {
        var _this = this;
        if (this._isDead) {
            return Promise.reject(new Error('Session is dead'));
        }
        this._isDead = true;
        var ajaxSettings = this.ajaxSettings;
        ajaxSettings.method = 'DELETE';
        ajaxSettings.dataType = 'json';
        ajaxSettings.cache = false;
        return utils.ajaxRequest(this._url, ajaxSettings).then(function (success) {
            if (success.xhr.status !== 204) {
                throw Error('Invalid Status: ' + success.xhr.status);
            }
            _this.sessionDied.emit(void 0);
            _this.kernel.dispose();
        }, function (rejected) {
            _this._isDead = false;
            if (rejected.xhr.status === 410) {
                throw Error('The kernel was deleted but the session was not');
            }
            onSessionError(rejected);
        });
    };
    /**
     * React to changes in the Kernel status.
     */
    NotebookSession.prototype._kernelStatusChanged = function (sender, state) {
        if (state == ikernel_1.KernelStatus.Dead) {
            this.shutdown();
        }
    };
    /**
     * A signal emitted when the session dies.
     *
     * **See also:** [[sessionDied]]
     */
    NotebookSession.sessionDiedSignal = new phosphor_signaling_1.Signal();
    return NotebookSession;
})();
/**
 * Handle an error on a session Ajax call.
 */
function onSessionError(error) {
    console.error("API request failed (" + error.statusText + "): ");
    throw Error(error.statusText);
}
/**
 * Throw a typed error.
 */
function typedThrow(msg) {
    throw new Error(msg);
}
